===== backend/backend/__init__.py =====
# backend/__init__.py
from .celery import app as celery_app

__all__ = ('celery_app',)


===== backend/backend/asgi.py =====
# backend/asgi.py

"""
ASGI config for backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os
import django
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
django.setup()

from game.routing import websocket_urlpatterns

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": URLRouter(websocket_urlpatterns),
})


===== backend/backend/celery.py =====
# backend/celery.py

import os
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

app = Celery('backend')
app.config_from_object('django.conf:settings', namespace='CELERY')
app.autodiscover_tasks()

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')


===== backend/backend/settings.py =====
# backend/settings.py
"""
Django settings for backend project.

Generated by 'django-admin startproject' using Django 5.1.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""
import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# TODO: Add key to .env and configure for production
# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-6_53z8qq@47jp9mr)%jy*@a$ly3xx*p_(k(-f+5ilb)y*%1a4i'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'corsheaders',
    'django_celery_results',
    'django_celery_beat',
    'channels',
    'game',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ALLOW_ALL_ORIGINS = True

ROOT_URLCONF = 'backend.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

ASGI_APPLICATION = 'backend.asgi.application'

CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            "hosts": [("redis", 6379)],
        },
    },
}

WSGI_APPLICATION = 'backend.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('DB_NAME', 'rpgdb'),
        'USER': os.environ.get('DB_USER', 'rpguser'),
        'PASSWORD': os.environ.get('DB_PASSWORD', 'rpgpass'),
        'HOST': os.environ.get('DB_HOST', 'db'),
        'PORT': os.environ.get('DB_PORT', '5432'),
    }
}

# Celery settings
CELERY_BROKER_URL = os.environ.get("REDIS_URL", "redis://redis:6379/0")
CELERY_RESULT_BACKEND = 'django-db'

CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers:DatabaseScheduler'
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'

CELERY_BEAT_SCHEDULE = {
    'check-and-advance-rounds-every-5-seconds': {
        'task': 'game.tasks.run_round_check',
        'schedule': 5.0,
    },
    'check-and-end-games-every-10-seconds': {
        'task': 'game.tasks.run_game_end_check',
        'schedule': 5.0,
    },
}

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Rest framework configuration
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
    ],
}


===== backend/backend/urls.py =====
# backend/urls.py
"""
URL configuration for backend project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('game.urls')),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


===== backend/backend/wsgi.py =====
# backend/wsgi.py
"""
WSGI config for backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

application = get_wsgi_application()


===== backend/game/__init__.py =====


===== backend/game/admin.py =====
# game/admin.py
from django.contrib import admin
from .models import Character, GameSession, Participant, QuestionCollection, Question, Round, Message, Guess

admin.site.register(Character)
admin.site.register(GameSession)
admin.site.register(Participant)
admin.site.register(QuestionCollection)
admin.site.register(Question)
admin.site.register(Round)
admin.site.register(Message)
admin.site.register(Guess)

===== backend/game/api_views.py =====
# game/api_views.py

import random, string, uuid
from datetime import timedelta
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from .models import GameSession, Participant, QuestionCollection, Message, Round
from django.utils import timezone
from django.db.models import F
from .utils import broadcast_chat_message, broadcast_lobby_update, broadcast_round_update

def generate_room_code(length=6):
    return ''.join(random.choices(string.ascii_uppercase, k=length))

@api_view(['POST'])
@permission_classes([AllowAny])
def create_room(request):
    attempts = 0
    while True:
        code = generate_room_code()
        if not GameSession.objects.filter(code=code).exists():
            break
        attempts += 1
        if attempts >= 100:
            return Response({'error': 'Serverio klaida: Nepavyko sukurti kambario.'}, status=500)

    session = GameSession.objects.create(code=code)
    
    return Response({
        'code': session.code,
        'status': session.status,
        'round_length': session.round_length,
        'round_count': session.round_count,
    })

@api_view(['POST'])
@permission_classes([AllowAny])
def join_room(request):
    code = request.data.get('code', '').strip()
    participant = None  # define upfront

    # Try reconnecting if participant_id and secret are provided.
    participant_id = request.data.get('participant_id')
    provided_secret = request.data.get('secret', '').strip()

    if participant_id and provided_secret:
        try:
            session = GameSession.objects.get(code=code)
        except GameSession.DoesNotExist:
            return Response({'error': 'Kambarys su tokiu kodu neegzistuoja.'}, status=404)
        try:
            participant = session.participants.get(id=participant_id)
        except Participant.DoesNotExist:
            participant = None
        if participant:
            if participant.secret != provided_secret:
                return Response({'error': 'Netinkamas slaptažodis.'}, status=403)
            # Rejoin successful.
        # Fall through to new join flow if participant not found.
    
    if not participant:
        try:
            session = GameSession.objects.get(code=code)
        except GameSession.DoesNotExist:
            return Response({'error': 'Kambarys su tokiu kodu neegzistuoja.'}, status=404)
        # New joins are allowed only when the room is pending.
        if session.status != 'pending':
            return Response({'error': 'Žaidimas jau prasidėjo arba baigėsi.'}, status=400)
        user = request.user if request.user.is_authenticated else None
        guest_username = None
        if not user:
            guest_username = request.data.get('guest_username', '').strip()
        name_to_join = user.username if user else guest_username
        if not name_to_join:
            return Response({'error': 'Prašome įvesti vartotojo vardą.'}, status=400)
        # Check for duplicate names (case-insensitive).
        existing_names = []
        for part in session.participants.all():
            if part.user:
                existing_names.append(part.user.username.lower())
            elif part.guest_name:
                existing_names.append(part.guest_name.lower())
        if name_to_join.lower() in existing_names:
            return Response({'error': 'Toks vartotojo vardas jau naudojamas kambaryje.'}, status=400)
        is_host_flag = (session.participants.count() == 0)
        if user:
            participant, created = Participant.objects.get_or_create(
                user=user,
                game_session=session,
                defaults={'is_host': is_host_flag}
            )
        else:
            participant = Participant.objects.create(
                user=None,
                game_session=session,
                guest_identifier=str(uuid.uuid4()),
                guest_name=guest_username,
                is_host=is_host_flag
            )
    # Broadcast the updated lobby state.
    from .utils import broadcast_lobby_update
    broadcast_lobby_update(session)
    players = []
    for part in session.participants.all():
        players.append({
            'id': part.id,
            'username': part.user.username if part.user else (part.guest_name if part.guest_name else (f"Guest {part.guest_identifier[:8]}" if part.guest_identifier else "Guest")),
            'characterSelected': part.assigned_character is not None,
            'is_host': part.is_host,
        })


    messages = []
    for msg in Message.objects.filter(round__game_session=session).order_by('sent_at'):
        messages.append({
            'text': msg.text,
            'sentAt': msg.sent_at.isoformat(),
            'roundNumber': msg.round.round_number,
            'characterImage': msg.participant.assigned_character.image.url
                            if msg.participant.assigned_character and msg.participant.assigned_character.image
                            else None,
            'characterName': msg.participant.assigned_character.name
                            if msg.participant.assigned_character else None,
        })

    collections_list = list(session.question_collections.values('id', 'name'))

    # If the session is in progress include current round information.
    current_round = None
    if session.status == 'in_progress':
        from django.utils import timezone
        current_round_obj = session.rounds.filter(end_time__gt=timezone.now()).order_by('-round_number').first()
        if current_round_obj:
            current_round = {
                'round_number': current_round_obj.round_number,
                'question': current_round_obj.question.text if current_round_obj.question else '',
                'end_time': current_round_obj.end_time.isoformat(),
            }
    
    return Response({
        'code': session.code,
        'status': session.status,
        'round_length': session.round_length,
        'round_count': session.round_count,
        'guess_timer': session.guess_timer,
        'guess_deadline': session.guess_deadline.isoformat() if session.guess_deadline else None,
        'players': players,
        'participant_id': participant.id,
        'secret': participant.secret,
        'is_host': participant.is_host,
        'current_round': current_round,
        'messages': messages,
        'question_collections': collections_list
    })

@api_view(['POST'])
@permission_classes([AllowAny])
def update_settings(request):
    code = request.data.get('code', '').strip()
    participant_id = request.data.get('participant_id')
    provided_secret = request.data.get('secret', '').strip()
    round_length = request.data.get('round_length')
    round_count = request.data.get('round_count')
    guess_timer = request.data.get('guess_timer')

    if not code or not participant_id or not provided_secret:
         return Response({'error': 'Kambario kodas, dalyvio ID ir slaptažodis privalomi.'}, status=400)
    try:
         session = GameSession.objects.get(code=code)
         participant = session.participants.get(id=participant_id)
    except (GameSession.DoesNotExist, Participant.DoesNotExist):
         return Response({'error': 'Neteisingas kambarys arba dalyvio ID.'}, status=404)
    
    if session.status != 'pending':
        return Response({'error': 'Negalima keisti kambario nustatymų, kai žaidimas jau prasidėjo.'}, status=400)

    if participant.secret != provided_secret:
         return Response({'error': 'Netinkamas slaptažodis.'}, status=403)

    if not participant.is_host:
         return Response({'error': 'Tik vedėjas gali keisti nustatymus.'}, status=403)

    try:
         round_length = int(round_length)
         round_count = int(round_count)
         if round_length <= 0 or round_length > 1200 or round_count <= 0 or round_count > 20:
              raise ValueError
    except (ValueError, TypeError):
         return Response({'error': 'Neteisingi raundų nustatymų duomenys.'}, status=400)

    if guess_timer is not None:
         try:
             guess_timer = int(guess_timer)
             if guess_timer <= 0 or guess_timer > 600:
                 raise ValueError
         except (ValueError, TypeError):
             return Response({'error': 'Neteisingi spėjimų laiko nustatymo duomenys.'}, status=400)
         session.guess_timer = guess_timer

    session.round_length = round_length
    session.round_count = round_count
    session.save()

    from .utils import broadcast_lobby_update
    broadcast_lobby_update(session)

    return Response({
         'code': session.code,
         'status': session.status,
         'round_length': session.round_length,
         'round_count': session.round_count,
         'guess_timer': session.guess_timer
    })

@api_view(['POST'])
@permission_classes([AllowAny])
def leave_room(request):
    code = request.data.get('code', '').strip()
    participant_id = request.data.get('participant_id')
    provided_secret = request.data.get('secret', '').strip()
    if not code or not participant_id or not provided_secret:
         return Response({'error': 'Kambario kodas, dalyvio ID ir slaptažodis privalomi.'}, status=400)
    try:
         session = GameSession.objects.get(code=code)
         participant = session.participants.get(id=participant_id)
    except (GameSession.DoesNotExist, Participant.DoesNotExist):
         return Response({'error': 'Neteisingas kambarys arba dalyvio ID.'}, status=404)

    if participant.secret != provided_secret:
         return Response({'error': 'Netinkamas slaptažodis.'}, status=403)

    was_host = participant.is_host

    # If game is in progress, mark the participant as inactive, otherwise delete.
    if session.status == 'in_progress':
         participant.is_active = False
         participant.save()
    else:
         participant.delete()

    remaining = session.participants.filter(is_active=True)
    if remaining.exists():
         # If the leaving participant was the host, transfer host privileges
         if was_host:
             oldest = remaining.order_by('joined_at').first()
             oldest.is_host = True
             oldest.save()
         from .utils import broadcast_lobby_update
         broadcast_lobby_update(session)
         return Response({'message': 'Išėjote iš kambario.'})
    else:
         # If no active participants remain, delete the session.
         session.delete()
         return Response({'message': 'Jūs buvote paskutinis kambaryje. Kambarys ištrintas.'})

@api_view(['GET'])
@permission_classes([AllowAny])
def verify_room(request):
    code = request.query_params.get('code', '').strip()
    if not code:
        return Response({'error': 'Prašome įrašyti kambario kodą!'}, status=400)
    try:
        session = GameSession.objects.get(code=code)
    except GameSession.DoesNotExist:
        return Response({'error': 'Kambarys su tokiu kodu neegzistuoja.'}, status=404)
    return Response({
        'code': session.code,
        'status': session.status,
        'round_length': session.round_length,
        'round_count': session.round_count,
    })

@api_view(['GET'])
@permission_classes([AllowAny])
def lobby_state(request):
    code = request.query_params.get('code', '').strip()
    if not code:
        return Response({'error': 'Kambario kodas privalomas.'}, status=400)
    try:
        session = GameSession.objects.get(code=code)
    except GameSession.DoesNotExist:
        return Response({'error': 'Toks kambarys nebuvo rastas.'}, status=404)
    
    players = []
    for part in session.participants.all():
        if part.user:
            players.append(part.user.username)
        else:
            # Use guest_name if set, otherwise a default based on guest_identifier.
            players.append(part.guest_name if part.guest_name else (f"Guest {part.guest_identifier[:8]}" if part.guest_identifier else "Guest"))
    
    data = {
        'code': session.code,
        'status': session.status,
        'round_length': session.round_length,
        'round_count': session.round_count,
        'players': players,
    }
    return Response(data)

@api_view(['POST'])
@permission_classes([AllowAny])
def update_question_collections(request):
    code = request.data.get('code', '').strip()
    participant_id = request.data.get('participant_id')
    provided_secret = request.data.get('secret', '').strip()
    collections_ids = request.data.get('collections', [])

    if not code or not participant_id or not provided_secret:
        return Response({'error': 'Kambario kodas, dalyvio ID ir slaptažodis privalomi.'}, status=400)

    try:
        session = GameSession.objects.get(code=code)
        participant = session.participants.get(id=participant_id)
    except (GameSession.DoesNotExist, Participant.DoesNotExist):
        return Response({'error': 'Neteisingas kambarys arba dalyvio ID.'}, status=404)
    
    if session.status != 'pending':
         return Response({'error': 'Negalima keisti klausimų kolekcijų, kai žaidimas jau prasidėjo.'}, status=400)

    if participant.secret != provided_secret:
        return Response({'error': 'Netinkamas slaptažodis.'}, status=403)

    if not participant.is_host:
        return Response({'error': 'Tik vedėjas gali keisti klausimų kolekcijas.'}, status=403)

    # Fetch valid collections from the provided IDs
    valid_collections = QuestionCollection.objects.filter(id__in=collections_ids)
    # Update the session's question collections.
    session.question_collections.set(valid_collections)
    session.save()

    from .utils import broadcast_lobby_update
    broadcast_lobby_update(session)

    collections_list = list(session.question_collections.values('id', 'name'))
    return Response({
         'code': session.code,
         'question_collections': collections_list,
    })

@api_view(['GET'])
@permission_classes([AllowAny])
def available_collections(request):
    collections = QuestionCollection.objects.all().values('id', 'name')
    return Response(list(collections))

@api_view(['POST'])
@permission_classes([AllowAny])
def select_character(request):
    code = request.data.get('code', '').strip()
    participant_id = request.data.get('participant_id')
    provided_secret = request.data.get('secret', '').strip()
    character_id = request.data.get('character_id')
    
    if not code or not participant_id or not provided_secret or not character_id:
        return Response({'error': 'Trūksta privalomų parametrų.'}, status=400)
    
    try:
        session = GameSession.objects.get(code=code)
        participant = session.participants.get(id=participant_id)
    except (GameSession.DoesNotExist, Participant.DoesNotExist):
        return Response({'error': 'Neteisingas kambario kodas arba dalyvio ID.'}, status=404)
    
    if session.status != 'pending':
         return Response({'error': 'Negalima keisti personažų, kai žaidimas jau prasidėjo.'}, status=400)
    
    if participant.secret != provided_secret:
        return Response({'error': 'Neteisingas slaptažodis.'}, status=403)
    
    try:
        from .models import Character
        character = Character.objects.get(id=character_id)
    except Character.DoesNotExist:
        return Response({'error': 'Personažas nerastas.'}, status=404)

    if session.participants.filter(assigned_character=character).exists():
        return Response({'error': 'Šis personažas jau pasirinktas.'}, status=400)
    
    participant.assigned_character = character
    participant.save()
    
    from .utils import broadcast_lobby_update
    broadcast_lobby_update(session)
    
    return Response({'message': 'Personažas pasirinktas.'})

@api_view(['POST'])
@permission_classes([AllowAny])
def create_character(request):
    code = request.data.get('code', '').strip()
    participant_id = request.data.get('participant_id')
    provided_secret = request.data.get('secret', '').strip()
    name = request.data.get('name', '').strip()
    description = request.data.get('description', '').strip()
    
    if not code or not participant_id or not provided_secret or not name:
        return Response({'error': 'Trūksta privalomų parametrų.'}, status=400)
    
    try:
        session = GameSession.objects.get(code=code)
        participant = session.participants.get(id=participant_id)
    except (GameSession.DoesNotExist, Participant.DoesNotExist):
        return Response({'error': 'Neteisingas kambario kodas arba dalyvio ID.'}, status=404)
    
    if session.status != 'pending':
        return Response({'error': 'Negalima keisti personažų, kai žaidimas jau prasidėjo.'}, status=400)
    
    if participant.secret != provided_secret:
        return Response({'error': 'Netinkas slaptažodis.'}, status=403)
    
    from .models import Character
    user = request.user if request.user.is_authenticated else None

    # Handle image upload, if provided.
    image = request.FILES.get('image')
    if image:
        # Validate that the file is an image.
        if not image.content_type.startswith('image/'):
            return Response({'error': 'Neteisingas failo tipas. Tinka .jpg, .png.'}, status=400)
        # Check file size (limit example: 5 MB)
        if image.size > 5 * 1024 * 1024:
            return Response({'error': 'Paveikslėlis per didelis. Didžiausias leidžiamas dydis yra 5MB.'}, status=400)
    
    new_character = Character.objects.create(
        name=name,
        description=description,
        creator=user,
        image=image
    )
    
    participant.assigned_character = new_character
    participant.save()
    
    from .utils import broadcast_lobby_update
    broadcast_lobby_update(session)
    
    return Response({'message': 'Personažas sukurtas ir pasirinktas.', 'character_id': new_character.id})


@api_view(['GET'])
@permission_classes([AllowAny])
def available_characters(request):
    from .models import Character
    characters = Character.objects.filter(creator__username="mostghoste").values('id', 'name', 'description', 'image')
    return Response(list(characters))


@api_view(['POST'])
@permission_classes([AllowAny])
def start_game(request):
    code = request.data.get('code', '').strip()
    participant_id = request.data.get('participant_id')
    provided_secret = request.data.get('secret', '').strip()

    if not code or not participant_id or not provided_secret:
         return Response({'error': 'Kambario kodas, dalyvio ID ir slaptažodis privalomi.'}, status=400)
    
    try:
         session = GameSession.objects.get(code=code)
         participant = session.participants.get(id=participant_id)
    except (GameSession.DoesNotExist, Participant.DoesNotExist):
         return Response({'error': 'Neteisingas kambarys arba dalyvio ID.'}, status=404)

    if participant.secret != provided_secret:
         return Response({'error': 'Netinkamas slaptažodis.'}, status=403)

    if not participant.is_host:
         return Response({'error': 'Tik vedėjas gali pradėti žaidimą.'}, status=403)
    
    if session.status != 'pending':
         return Response({'error': 'Žaidimas jau prasidėjo arba baigėsi.'}, status=400)

    if session.participants.count() < 3:
         return Response({'error': 'Žaidimui reikia bent 3 dalyvių.'}, status=400)
    
    if session.participants.filter(assigned_character__isnull=True).exists():
         return Response({'error': 'Kiekvienas dalyvis privalo turėti personažą.'}, status=400)
    
    total_questions = sum(collection.questions.count() for collection in session.question_collections.all())
    if total_questions <= session.round_count:
         return Response({'error': 'Klausimų kolekcijose nepakanka klausimų pagal nurodytą raundų skaičių.'}, status=400)

    # All checks passed; change game status.
    session.status = 'in_progress'
    session.save()

    # Create the first round.
    round_number = 1
    start_time = timezone.now()
    end_time = start_time + timedelta(seconds=session.round_length)
    
    # Choose a random question from a random collection
    question = None
    if session.question_collections.exists():
        collections = list(session.question_collections.all())
        collection = random.choice(collections)
        questions = list(collection.questions.all())
        if questions:
            question = random.choice(questions)

    new_round = Round.objects.create(
        game_session=session,
        question=question,
        round_number=round_number,
        start_time=start_time,
        end_time=end_time
    )

    # Broadcast round update so clients can display the question, round number, and time left.
    broadcast_round_update(session.code, new_round)
    
    # Update lobby state for everyone.
    broadcast_lobby_update(session)
    
    return Response({
         'message': 'Žaidimas pradėtas.',
         'code': session.code,
         'status': session.status,
         'round_length': session.round_length,
         'round_count': session.round_count,
         'current_round': {
              'round_number': new_round.round_number,
              'question': new_round.question.text if new_round.question else '',
              'end_time': new_round.end_time.isoformat(),
         }
    })

@api_view(['POST'])
@permission_classes([AllowAny])
def send_chat_message(request):
    code = request.data.get('code', '').strip()
    participant_id = request.data.get('participant_id')
    secret = request.data.get('secret', '').strip()
    text = request.data.get('text', '').strip()

    if not code or not participant_id or not secret or not text:
        return Response({'error': 'Trūksta reikiamų laukų.'}, status=400)

    # Retrieve the game session
    try:
        session = GameSession.objects.get(code=code)
    except GameSession.DoesNotExist:
        return Response({'error': 'Nerasta žaidimo sesija.'}, status=404)

    # Only allow chat in "pending" or "in_progress" (example logic)
    if session.status not in ['pending', 'in_progress']:
        return Response({'error': 'Šios žaidimo stadijos metu žinučių siųsti negalima.'}, status=400)

    # Retrieve the participant
    try:
        participant = Participant.objects.get(id=participant_id, game_session=session)
    except Participant.DoesNotExist:
        return Response({'error': 'Dalyvis nerastas.'}, status=404)

    if participant.secret != secret:
        return Response({'error': 'Netinkamas slaptažodis.'}, status=403)

    current_round = session.rounds.filter(end_time__gt=timezone.now()).order_by('-round_number').first()
    if not current_round:
        return Response({'error': 'Palaukite sekančio raundo.'}, status=400)
    
    # Create the message in DB
    msg = Message.objects.create(
        participant=participant,
        round=current_round,
        text=text
    )

    # Broadcast the new message to the WebSocket group
    broadcast_chat_message(session.code, msg)

    return Response({'message': 'Žinutė išsiųsta.'})

@api_view(['GET'])
@permission_classes([AllowAny])
def available_guess_options(request):
    code = request.query_params.get('code', '').strip()
    if not code:
        return Response({'error': 'Prašome įvesti kambario kodą.'}, status=400)
    try:
        session = GameSession.objects.get(code=code)
    except GameSession.DoesNotExist:
        return Response({'error': 'Kambarys nerastas.'}, status=404)
    
    if session.status != 'guessing':
        return Response({'error': 'Spėjimų pasirinkimai prieinami tik spėjimų fazėje.'}, status=400)
    
    # Get unique assigned characters
    assigned_chars = (
        session.participants
        .filter(assigned_character__isnull=False)
        .values('assigned_character__id', 'assigned_character__name', 'assigned_character__image')
        .distinct()
    )
    options = []
    for char in assigned_chars:
        options.append({
            'character_id': char['assigned_character__id'],
            'character_name': char['assigned_character__name'],
            'character_image': char['assigned_character__image'] if char['assigned_character__image'] else None
        })
    
    return Response(options)

@api_view(['POST'])
@permission_classes([AllowAny])
def submit_guesses(request):
    from .models import GameSession, Participant, Guess, Character

    code = request.data.get('code', '').strip()
    participant_id = request.data.get('participant_id')
    secret = request.data.get('secret', '').strip()
    guesses_data = request.data.get('guesses', [])

    # Validate session & participant
    try:
        session = GameSession.objects.get(code=code)
        participant = Participant.objects.get(id=participant_id, game_session=session)
    except (GameSession.DoesNotExist, Participant.DoesNotExist):
        return Response({'error': 'Neteisingas kambarys arba dalyvio ID.'}, status=404)

    if participant.secret != secret:
        return Response({'error': 'Netinkamas slaptažodis.'}, status=403)

    if session.status != 'guessing':
        return Response({'error': 'Šiuo metu negalima pateikti spėjimų (ne spėjimų fazė).'}, status=400)

    if session.guess_deadline and timezone.now() > session.guess_deadline:
        return Response({'error': 'Laikas spėjimams pasibaigė.'}, status=400)
    
    # Limit total guesses to (number_of_participants - 1)
    max_guesses = session.participants.count() - 1
    if len(guesses_data) > max_guesses:
        return Response({'error': 'Per daug spėjimų.'}, status=400)

    # Check for duplicates within the current submission
    guessed_participant_ids = set()
    for g in guesses_data:
        gp_id = g.get('guessed_participant_id')
        if not gp_id:
            return Response({'error': 'Trūksta guessed_participant_id lauko.'}, status=400)
        if gp_id == participant.id:
            return Response({'error': 'Negalite spėti savęs.'}, status=400)
        if gp_id in guessed_participant_ids:
            return Response({'error': 'Negalite spėti to paties dalyvio daugiau nei vieną kartą.'}, status=400)
        guessed_participant_ids.add(gp_id)

    # Get all character IDs that are valid in this session
    assigned_char_ids = set(
        session.participants
               .exclude(assigned_character=None)
               .values_list('assigned_character_id', flat=True)
    )

    updated_guesses = []
    for guess_info in guesses_data:
        gp_id = guess_info['guessed_participant_id']
        gc_id = guess_info.get('guessed_character_id')
        if not gc_id:
            return Response({'error': 'Trūksta guessed_character_id lauko.'}, status=400)

        # Validate the guessed participant
        try:
            guessed_participant = session.participants.get(id=gp_id)
        except Participant.DoesNotExist:
            return Response({'error': 'Neteisingas guessed_participant_id.'}, status=404)

        if not guessed_participant.assigned_character:
            return Response({'error': 'Šis dalyvis neturi priskirto personažo.'}, status=400)

        # Ensure the character belongs to this session
        if gc_id not in assigned_char_ids:
            return Response({'error': 'Šis personažas nepriklauso šiam kambariui.'}, status=400)

        # Determine if the guess is correct
        is_correct = (guessed_participant.assigned_character_id == gc_id)

        # Update existing guess only if the guessed character is different;
        # otherwise, if it doesn't exist, create it.
        try:
            guess = Guess.objects.get(guesser=participant, guessed_participant=guessed_participant)
            if guess.guessed_character_id != gc_id:
                guess.guessed_character_id = gc_id
                guess.is_correct = is_correct
                guess.save()
        except Guess.DoesNotExist:
            guess = Guess.objects.create(
                guesser=participant,
                guessed_participant=guessed_participant,
                guessed_character_id=gc_id,
                is_correct=is_correct
            )
        updated_guesses.append(guess.id)

    return Response({
        'message': 'Spėjimai sėkmingai pateikti.',
        'guesses_updated': updated_guesses
    })



===== backend/game/apps.py =====
# game/apps.py

from django.apps import AppConfig


class GameConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'game'


===== backend/game/consumers.py =====
# game/consumers.py
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from .models import GameSession, Participant
from asgiref.sync import sync_to_async
from django.utils import timezone

class LobbyConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_code = self.scope['url_route']['kwargs']['room_code']
        self.group_name = f'lobby_{self.room_code}'
        await self.channel_layer.group_add(self.group_name, self.channel_name)
        await self.accept()
        await self.send_initial_state()

    async def send_initial_state(self):
        try:
            session = await sync_to_async(GameSession.objects.get)(code=self.room_code)
        except GameSession.DoesNotExist:
            await self.close()
            return

        participants = await sync_to_async(list)(
            session.participants.all().order_by('joined_at').select_related('assigned_character')
        )

        players = []
        host_id = None
        for part in participants:
            if part.user:
                username = part.user.username
            else:
                username = part.guest_name if part.guest_name else (f"Guest {part.guest_identifier[:8]}" if part.guest_identifier else "Guest")
            if part.is_host:
                username += " 👑"
                host_id = part.id
            # Now this check won't trigger a new DB query.
            character_selected = part.assigned_character is not None
            players.append({
                'id': part.id,
                'username': username,
                'characterSelected': character_selected,
            })

        collections = await sync_to_async(list)(
            session.question_collections.values('id', 'name')
        )
        data = {
            'code': session.code,
            'players': players,
            'host_id': host_id,
            'status': session.status,
            'round_length': session.round_length,
            'round_count': session.round_count,
            'question_collections': collections,
        }
        await self.send(text_data=json.dumps(data))

    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(self.group_name, self.channel_name)

    async def receive(self, text_data):
        data = json.loads(text_data)
        if data.get('type') == 'ping':
            participant_id = data.get('participant_id')
            if participant_id:
                try:
                    participant = await sync_to_async(Participant.objects.get)(id=participant_id)
                    participant.last_seen = timezone.now()
                    await sync_to_async(participant.save)()
                except Participant.DoesNotExist:
                    print("ERROR: Couldn't find the participant to update.")
            return
        
    async def lobby_update(self, event):
        data = event['data']
        await self.send(text_data=json.dumps(data))

===== backend/game/models.py =====
# game/models.py

import uuid, os
from django.db import models
from django.contrib.auth.models import User

def get_character_image_upload_path(instance, filename):
    # Extract the file extension
    ext = filename.split('.')[-1]
    # Generate a unique filename using uuid4
    new_filename = f"{uuid.uuid4().hex}.{ext}"
    # Return the full path where the file will be stored
    return os.path.join("character_images", new_filename)

class Character(models.Model):
    name = models.CharField(max_length=50)
    description = models.TextField(blank=True)
    image = models.ImageField(upload_to=get_character_image_upload_path, null=True, blank=True)
    # When a creator (User) is deleted, set field to NULL (Don't delete the character).
    creator = models.ForeignKey(
        User, on_delete=models.SET_NULL, null=True, blank=True, related_name='created_characters'
    )
    created_at = models.DateTimeField(auto_now_add=True)  # Set once at creation.
    updated_at = models.DateTimeField(auto_now=True)  # Updated on each save.

    def __str__(self):
        return self.name

class GameSession(models.Model):
    STATUS_CHOICES = (
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('guessing', "Guessing"),
        ('completed', 'Completed'),
    )
    code = models.CharField(max_length=20)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    round_length = models.IntegerField(default=60)  # Round duration in seconds.
    round_count = models.IntegerField(default=3)    # Total number of rounds for the session.
    guess_timer = models.IntegerField(default=60)  # Timer (in seconds) for guessing phase.
    guess_deadline = models.DateTimeField(null=True, blank=True) # Deadline for submitting guesses.

    # A session can reference one or several question collections.
    question_collections = models.ManyToManyField(
        'QuestionCollection', blank=True, related_name='game_sessions'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return f"Session {self.code} ({self.status})"

def generate_secret():
    return uuid.uuid4().hex

class Participant(models.Model):
    # if the user is deleted, keep their participant record.
    user = models.ForeignKey(User, on_delete=models.SET_NULL, related_name='participants', null=True, blank=True)
    guest_identifier = models.CharField(max_length=36, null=True, blank=True)
    guest_name = models.CharField(max_length=50, null=True, blank=True)
    # if the session is deleted, remove all its participants.
    game_session = models.ForeignKey(
        GameSession, on_delete=models.CASCADE, related_name='participants'
    )
    # if the character is deleted, set assigned_character to NULL.
    assigned_character = models.ForeignKey(
        Character, on_delete=models.SET_NULL, null=True, blank=True, related_name='participants'
    )
    points = models.IntegerField(default=0)
    joined_at = models.DateTimeField(auto_now_add=True)
    last_seen = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)
    secret = models.CharField(max_length=64, default=generate_secret)
    is_host = models.BooleanField(default=False)

    class Meta:
        constraints = [
            # For authenticated users, ensure a user can join a session only once.
            models.UniqueConstraint(
                fields=['user', 'game_session'],
                condition=models.Q(user__isnull=False),
                name='unique_user_session'
            ),
            # For guest users, use guest_identifier to ensure uniqueness within a session.
            models.UniqueConstraint(
                fields=['guest_identifier', 'game_session'],
                condition=models.Q(user__isnull=True),
                name='unique_guest_session'
            )
        ]

    def __str__(self):
        if self.user:
            username = self.user.username
        elif self.guest_name:
            username = self.guest_name
        elif self.guest_identifier:
            username = f"Guest {self.guest_identifier[:8]}"
        else:
            username = "Guest"
        return f"{username} in session {self.game_session.code}"

class Question(models.Model):
    text = models.TextField()
    creator = models.ForeignKey(
        User, on_delete=models.SET_NULL, null=True, blank=True, related_name='created_questions'
    )
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.text[:50]

class QuestionCollection(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    questions = models.ManyToManyField(Question, blank=True, related_name='collections')
    # When a user who created the collection is deleted, set this to NULL.
    created_by = models.ForeignKey(
        User, on_delete=models.SET_NULL, null=True, blank=True, related_name='question_collections'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name

class Round(models.Model):
    game_session = models.ForeignKey(
        GameSession, on_delete=models.CASCADE, related_name='rounds'
    )
    # prevent deletion of a question if it’s used in a round.
    question = models.ForeignKey(Question, on_delete=models.PROTECT)
    round_number = models.PositiveIntegerField()
    start_time = models.DateTimeField(auto_now_add=True)
    end_time = models.DateTimeField(null=True, blank=True)

    class Meta:
        unique_together = ('game_session', 'round_number')

    def __str__(self):
        return f"Round {self.round_number} in session {self.game_session.code}"

class Message(models.Model):
    participant = models.ForeignKey(
        Participant, on_delete=models.SET_NULL, related_name='messages', null=True
    )
    round = models.ForeignKey(
        Round, on_delete=models.CASCADE, related_name='messages'
    )
    text = models.TextField()
    sent_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        if self.participant:
            if self.participant.user:
                name = self.participant.user.username
            elif self.participant.guest_name:
                name = self.participant.guest_name
            elif self.participant.guest_identifier:
                name = f"Guest {self.participant.guest_identifier[:8]}"
            else:
                name = "Guest"
        else:
            name = "Unknown"
        return f"Message from {name} in round {self.round.round_number}"


class Guess(models.Model):
    # The participant making the guess.
    guesser = models.ForeignKey(
        Participant, on_delete=models.CASCADE, related_name='guesses_made'
    )
    # The participant who is being guessed (matched to the role).
    guessed_participant = models.ForeignKey(
        Participant, on_delete=models.CASCADE, related_name='guesses_received'
    )
    # The character (role) being guessed.
    guessed_character = models.ForeignKey(
        Character, on_delete=models.CASCADE, related_name='guesses'
    )
    is_correct = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        # Determine guesser name
        if self.guesser:
            if self.guesser.user:
                guesser_name = self.guesser.user.username
            elif self.guesser.guest_name:
                guesser_name = self.guesser.guest_name
            elif self.guesser.guest_identifier:
                guesser_name = f"Guest {self.guesser.guest_identifier[:8]}"
            else:
                guesser_name = "Guest"
        else:
            guesser_name = "Unknown"

        # Determine guessed participant name
        if self.guessed_participant:
            if self.guessed_participant.user:
                guessed_participant_name = self.guessed_participant.user.username
            elif self.guessed_participant.guest_name:
                guessed_participant_name = self.guessed_participant.guest_name
            elif self.guessed_participant.guest_identifier:
                guessed_participant_name = f"Guest {self.guessed_participant.guest_identifier[:8]}"
            else:
                guessed_participant_name = "Guest"
        else:
            guessed_participant_name = "Unknown"

        return f"{guesser_name} guessed {self.guessed_character.name} for {guessed_participant_name}"

===== backend/game/routing.py =====
# game/routing.py

from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/lobby/(?P<room_code>\w+)/$', consumers.LobbyConsumer.as_asgi())
]


===== backend/game/tasks.py =====
# game/tasks.py

from celery import shared_task
from django.utils import timezone
from datetime import timedelta
from .models import GameSession
from .utils import check_and_advance_rounds, broadcast_lobby_update

@shared_task
def run_round_check():
    print("⏰ Celery: Checking rounds...")
    check_and_advance_rounds()

@shared_task
def run_game_end_check():
    now = timezone.now()
    # Find sessions in the guessing phase whose deadline has passed
    sessions = GameSession.objects.filter(status='guessing', guess_deadline__lte=now)
    for session in sessions:
        print(f"Ending game for session {session.code}")
        # Calculate results for each participant
        for participant in session.participants.all():
            # Calculate points based on correct guesses
            correct_guess_count = participant.guesses_made.filter(is_correct=True).count()
            points_from_guesses = correct_guess_count * 50
            
            rounds_with_messages = session.rounds.filter(messages__participant=participant).distinct().count()
            points_from_messages = rounds_with_messages * 100
            
            total_points = points_from_guesses + points_from_messages
            participant.points = total_points
            participant.save()
        
        # Change the session status to 'completed'
        session.status = 'completed'
        session.save()
        
        # Broadcast the updated lobby so that clients know the game is over
        broadcast_lobby_update(session)
        
    return "Game end check complete"

===== backend/game/tests.py =====
# game/tests.py

from django.test import TestCase

# Create your tests here.


===== backend/game/urls.py =====
# game/urls.py

from django.urls import path
from .api_views import (
    create_room,
    join_room,
    update_settings,
    update_question_collections,
    available_collections,
    verify_room,
    lobby_state,
    leave_room,
    start_game,
    select_character,
    create_character,
    available_characters,
    send_chat_message,
    submit_guesses,
    available_guess_options
)

urlpatterns = [
    path('create_room/', create_room, name='create_room'),
    path('join_room/', join_room, name='join_room'),
    path('update_settings/', update_settings, name='update_settings'),
    path('update_question_collections/', update_question_collections, name='update_question_collections'),
    path('available_collections/', available_collections, name="available_collections"),
    path('verify_room/', verify_room, name='verify_room'),
    path('lobby_state/', lobby_state, name='lobby_state'),
    path('leave_room/', leave_room, name='leave_room'),
    path('start_game/', start_game, name='start_game'),
    path('select_character/', select_character, name='select_character'),
    path('create_character/', create_character, name='create_character'),
    path('available_characters/', available_characters, name='available_characters'),
    path('send_chat_message/', send_chat_message, name='send_chat_message'),
    path('submit_guesses/', submit_guesses, name='submit_guesses'),
    path('available_guess_options/', available_guess_options, name='available_guess_options'),
]


===== backend/game/utils.py =====
# game/utils.py

import random
from datetime import timedelta
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer
from django.utils import timezone
from .models import GameSession, Round

def broadcast_lobby_update(session):
    channel_layer = get_channel_layer()
    group_name = f'lobby_{session.code}'

    players = []
    host_id = None
    for part in session.participants.all().order_by('joined_at'):
        if part.is_host:
            host_id = part.id
        player_data = {
            'id': part.id,
            'username': part.user.username if part.user else (part.guest_name or f"Guest {part.guest_identifier[:8]}"),
            'characterSelected': part.assigned_character is not None,
            'is_host': part.is_host,
        }
        if session.status == 'completed':
            player_data['points'] = part.points
        players.append(player_data)

    collections_list = list(session.question_collections.values('id', 'name'))

    data = {
        'code': session.code,
        'players': players,
        'status': session.status,
        'round_length': session.round_length,
        'round_count': session.round_count,
        'guess_timer': session.guess_timer,
        'guess_deadline': session.guess_deadline.isoformat() if session.guess_deadline else None,
        'question_collections': collections_list,
        'host_id': host_id,
    }
    async_to_sync(channel_layer.group_send)(
        group_name,
        {'type': 'lobby_update', 'data': data}
    )


def broadcast_chat_message(room_code, message_obj):
    channel_layer = get_channel_layer()
    participant = message_obj.participant
    character = participant.assigned_character

    data = {
        'type': 'chat_update',
        'message': {
            'id': message_obj.id,
            'text': message_obj.text,
            'sentAt': message_obj.sent_at.isoformat(),
            'characterName': character.name if character else '???',
            'characterImage': character.image.url if (character and character.image) else None
        }
    }

    async_to_sync(channel_layer.group_send)(
        f'lobby_{room_code}',
        {
            'type': 'lobby_update',
            'data': data
        }
    )

def broadcast_round_update(room_code, round_obj):
    channel_layer = get_channel_layer()
    data = {
         'type': 'round_update',
         'round': {
              'round_number': round_obj.round_number,
              'question': round_obj.question.text if round_obj.question else '',
              'end_time': round_obj.end_time.isoformat(),
         }
    }
    async_to_sync(channel_layer.group_send)(
         f'lobby_{room_code}',
         {'type': 'lobby_update', 'data': data}
    )

def check_and_advance_rounds():
    print("⏰ Checking in-progress sessions...")
    now = timezone.now()
    sessions = GameSession.objects.filter(status='in_progress')

    for session in sessions:
        latest_round = (
            Round.objects
            .filter(game_session=session)
            .order_by('-round_number')
            .first()
        )
        # First round is created when host starts the game so this is redundant
        if not latest_round:
            print(f"🆕 No rounds yet for session {session.code}. Starting round 1.")
            next_round_number = 1
        else:
            if latest_round.end_time > now:
                print(f"⏳ Round {latest_round.round_number} in session {session.code} is still ongoing.")
                continue
            next_round_number = latest_round.round_number + 1

        if next_round_number > session.round_count:
            print(f"✅ Session {session.code} finished all rounds. Moving to 'guessing'.")
            session.status = 'guessing'
            session.guess_deadline = now + timedelta(seconds=session.guess_timer)
            session.save()
            broadcast_lobby_update(session)
            continue

        collections = list(session.question_collections.all())
        question = None
        if collections:
            collection = random.choice(collections)
            questions = list(collection.questions.exclude(round__game_session=session))
            if questions:
                question = random.choice(questions)
        end_time = now + timedelta(seconds=session.round_length)
        new_round = Round.objects.create(
            game_session=session,
            question=question,
            round_number=next_round_number,
            end_time=end_time
        )
        print(f"🌀 Created round {next_round_number} in session {session.code}")
        broadcast_round_update(session.code, new_round)
        broadcast_lobby_update(session)


===== backend/game/views.py =====
# game/views.py

from django.shortcuts import render

# Create your views here.


===== backend/Dockerfile =====
# backend/Dockerfile

# Use a python3 image
FROM python:3

# Create working directory
WORKDIR /app

# Copy requirements
COPY requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the backend code
COPY . .


===== frontend/Dockerfile =====
# frontend/Dockerfile

# Build step
FROM node:18-alpine as build

# Accept build arguments and set them as an env var for Vite
ARG VITE_API_BASE_URL
ENV VITE_API_BASE_URL=${VITE_API_BASE_URL}

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Production step (serving static files via nginx)
FROM nginx:stable-alpine

# Copy built assets from the build step
COPY --from=build /app/build /usr/share/nginx/html

# Copy custom nginx config
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]


===== frontend/src/routes/lobby/[code]/+page.js =====
export const prerender = false;

===== frontend/src/routes/lobby/[code]/+page.server.js =====
import { redirect } from '@sveltejs/kit';

export async function load({ params, request, fetch, locals }) {
  const code = params.code;

  // Verify the room exists.
  const verifyRes = await fetch(`${import.meta.env.VITE_API_BASE_URL}/api/verify_room/?code=${encodeURIComponent(code)}`, { method: 'GET' });
  if (!verifyRes.ok) {
    throw redirect(303, '/');
  }
  const verifyData = await verifyRes.json();
  if (!['pending', 'in_progress', 'guessing'].includes(verifyData.status)) {
    throw redirect(303, '/');
  }

  // If authenticated, join automatically.
  if (locals.user) {
    const res = await fetch(`${import.meta.env.VITE_API_BASE_URL}/api/join_room/`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ code })
    });
    if (!res.ok) throw redirect(303, '/');
    const lobbyState = await res.json();
    return { lobbyState, needsUsername: false };
  }

  // For unauthenticated users:
  // If the room is pending, require a guest username.
  if (verifyData.status === 'pending') {
    return { roomCode: code, needsUsername: true };
  }
  // Otherwise (if the game is already underway) let the client try to rejoin.
  return { lobbyState: verifyData, needsUsername: false };
}

===== frontend/src/routes/lobby/[code]/+page.svelte =====
<script>
	import { onMount, onDestroy } from 'svelte';
	import { goto } from '$app/navigation';
	import { browser } from '$app/environment';
	const API_URL = import.meta.env.VITE_API_BASE_URL;

	export let data;
	let needsUsername = data.needsUsername;
	let code = needsUsername ? data.roomCode : data.lobbyState.code;
	let lobbyState = needsUsername ? {} : data.lobbyState;
	let players = needsUsername ? [] : lobbyState.players || [];
	let errorMessage = '';

	// Use sessionStorage for per‑tab credentials.
	let participantId = lobbyState?.participant_id;
	let participantSecret = lobbyState?.secret;
	if (browser) {
		if (participantId) {
			sessionStorage.setItem('participantId', participantId);
		} else {
			participantId = sessionStorage.getItem('participantId');
		}
		if (participantSecret) {
			sessionStorage.setItem('participantSecret', participantSecret);
		} else {
			participantSecret = sessionStorage.getItem('participantSecret');
		}
	}

	let guestUsername = '';
	let socket;
	let heartbeatInterval;

	$: isHost = lobbyState.is_host || false;
	let roundLength = lobbyState?.round_length || 60;
	let roundCount = lobbyState?.round_count || 3;
	// NEW: guessTimer setting, visible to all users
	let guessTimer = lobbyState?.guess_timer || 60;

	let availableCollections = [];
	let selectedCollections = [];

	let availableCharacters = [];
	let newCharacterName = '';
	let newCharacterDescription = '';
	let newCharacterImage;

	// --- Chat State (Game Chat) ---
	let chatMessages = [];
	let chatInput = '';

	let currentRound = { round_number: null, question: '', end_time: null };
	let timeLeft = 0;
	function updateTimeLeft() {
		if (currentRound.end_time) {
			const endTime = new Date(currentRound.end_time);
			timeLeft = Math.max(0, Math.floor((endTime - Date.now()) / 1000));
		}
	}
	const timerInterval = setInterval(updateTimeLeft, 1000);

	async function fetchAvailableCollections() {
		try {
			const res = await fetch(`${API_URL}/api/available_collections/`);
			if (res.ok) {
				availableCollections = await res.json();
			} else {
				console.error('Failed to fetch available collections');
			}
		} catch (err) {
			console.error('Error fetching available collections:', err);
		}
	}

	async function fetchAvailableCharacters() {
		try {
			const res = await fetch(`${API_URL}/api/available_characters/`);
			if (res.ok) {
				availableCharacters = await res.json();
			}
		} catch (error) {
			console.error('Error fetching characters', error);
		}
	}

	function connectWebSocket() {
		// Avoid creating a new socket if one is already open.
		if (socket && socket.readyState === WebSocket.OPEN) {
			console.log('WebSocket already connected.');
			return;
		}
		let baseUrl = API_URL || 'http://localhost:8000';
		if (baseUrl.startsWith('https://')) {
			baseUrl = baseUrl.replace('https://', 'wss://');
		} else if (baseUrl.startsWith('http://')) {
			baseUrl = baseUrl.replace('http://', 'ws://');
		}
		const wsUrl = `${baseUrl}/ws/lobby/${code}/`;
		socket = new WebSocket(wsUrl);

		socket.onopen = () => {
			console.log(`Connected to lobby: ${code}`);
			heartbeatInterval = setInterval(() => {
				if (socket.readyState === WebSocket.OPEN) {
					socket.send(JSON.stringify({ type: 'ping' }));
				}
			}, 15000);
		};

		socket.onerror = (event) => {
			console.error('WebSocket error:', event);
			errorMessage = 'Nepavyko prisijungti prie WS.';
		};

		socket.onmessage = (event) => {
			const data = JSON.parse(event.data);
			if (data.status) {
				lobbyState.status = data.status;
			}
			if (data.players) {
				players = data.players;
			}
			if (data.round_length && data.round_count) {
				roundLength = data.round_length;
				roundCount = data.round_count;
			}
			if (data.guess_timer !== undefined) {
				guessTimer = data.guess_timer;
			}
			if (data.guess_deadline !== undefined) {
				lobbyState.guess_deadline = data.guess_deadline;
			}
			if (data.question_collections) {
				lobbyState.question_collections = data.question_collections;
				if (isHost) {
					selectedCollections = data.question_collections.map((qc) => qc.id);
				}
			}
			if (data.host_id !== undefined) {
				const newIsHost = parseInt(data.host_id) === parseInt(participantId);
				isHost = newIsHost;
				if (newIsHost) fetchAvailableCollections();
			}
			if (data.type === 'chat_update' && data.message) {
				// Append incoming chat message.
				chatMessages = [...chatMessages, data.message];
			}
			if (data.type === 'round_update' && data.round) {
				currentRound = data.round;
				updateTimeLeft();
			}
		};

		socket.onclose = (event) => {
			console.log('WebSocket disconnected:', event.code, event.reason);
		};
	}

	async function rejoinRoom() {
		try {
			const storedId = sessionStorage.getItem('participantId');
			const storedSecret = sessionStorage.getItem('participantSecret');
			console.log('Rejoin attempt: storedId =', storedId, 'storedSecret =', storedSecret);

			const res = await fetch(`${API_URL}/api/join_room/`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ code, participant_id: storedId, secret: storedSecret })
			});
			console.log('Rejoin response status:', res.status);
			if (res.ok) {
				const data = await res.json();
				console.log('Rejoin successful. Received lobbyState:', data);
				// Update lobby state based on rejoin response.
				lobbyState = data;
				players = lobbyState.players || [];
				roundLength = lobbyState.round_length || 60;
				roundCount = lobbyState.round_count || 60;
				guessTimer = lobbyState.guess_timer || 60;
				participantId = lobbyState.participant_id;
				participantSecret = lobbyState.secret;
				sessionStorage.setItem('participantId', participantId);
				sessionStorage.setItem('participantSecret', participantSecret);

				// Set current round info if provided.
				if (lobbyState.current_round) {
					currentRound = lobbyState.current_round;
				}
				// Load previous chat messages.
				if (lobbyState.messages) {
					chatMessages = lobbyState.messages;
				}
				// Update any question collection data if provided.
				if (lobbyState.question_collections) {
					selectedCollections = lobbyState.question_collections.map((qc) => qc.id);
				}

				connectWebSocket();
				if (isHost) fetchAvailableCollections();
				needsUsername = false;
			} else {
				const errorData = await res.json();
				console.error('Rejoin failed with error data:', errorData);
				errorMessage = errorData.error || 'Nepavyko atkurti ryšio.';
				setTimeout(() => goto('/'), 3000);
			}
		} catch (err) {
			console.error('Rejoin encountered an exception:', err);
			errorMessage = 'Serverio klaida bandant atkurti ryšį.';
			setTimeout(() => goto('/'), 3000);
		}
	}

	async function submitGuestUsername() {
		if (!guestUsername) {
			errorMessage = 'Prašome įvesti vartotojo vardą.';
			return;
		}
		errorMessage = '';
		try {
			const res = await fetch(`${API_URL}/api/join_room/`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ code, guest_username: guestUsername })
			});
			if (!res.ok) {
				const data = await res.json().catch(() => ({}));
				errorMessage = data.error ?? 'Nepavyko prisijungti.';
				return;
			}
			const data = await res.json();
			lobbyState = data;
			players = lobbyState.players || [];
			participantId = lobbyState.participant_id;
			participantSecret = lobbyState.secret;
			if (browser && participantId) {
				sessionStorage.setItem('participantId', participantId);
				sessionStorage.setItem('participantSecret', participantSecret);
				sessionStorage.setItem('roomCode', code);
			}
			isHost = lobbyState.is_host || false;
			roundLength = lobbyState.round_length || 60;
			roundCount = lobbyState.round_count || 60;
			guessTimer = lobbyState.guess_timer || 60;
			if (lobbyState.question_collections) {
				selectedCollections = lobbyState.question_collections.map((qc) => qc.id);
			}
			needsUsername = false;
			connectWebSocket();
			if (isHost) {
				fetchAvailableCollections();
			}
		} catch (err) {
			console.error(err);
			errorMessage = 'Serverio klaida bandant prisijungti prie kambario.';
		}
	}

	async function leaveLobby() {
		try {
			const secret = sessionStorage.getItem('participantSecret');
			const res = await fetch(`${API_URL}/api/leave_room/`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					code,
					participant_id: participantId,
					secret: secret
				})
			});
			if (!res.ok) {
				const data = await res.json();
				errorMessage = data.error || 'Nepavyko išeiti iš kambario.';
				return;
			}
			sessionStorage.removeItem('participantId');
			sessionStorage.removeItem('participantSecret');
			goto('/');
		} catch (err) {
			console.error(err);
			errorMessage = 'Serverio klaida bandant išeiti iš kambario.';
		}
	}

	async function updateSettings() {
		try {
			const secret = sessionStorage.getItem('participantSecret');
			const res = await fetch(`${API_URL}/api/update_settings/`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					code,
					participant_id: participantId,
					secret,
					round_length: roundLength,
					round_count: roundCount,
					guess_timer: guessTimer // NEW: send the guess timer
				})
			});
			if (!res.ok) {
				const data = await res.json();
				errorMessage = data.error || 'Nepavyko atnaujinti nustatymų.';
				return;
			}
			const updated = await res.json();
			roundLength = updated.round_length;
			roundCount = updated.round_count;
			guessTimer = updated.guess_timer; // update guessTimer from response
		} catch (err) {
			console.error(err);
			errorMessage = 'Serverio klaida atnaujinant nustatymus.';
		}
	}

	async function updateCollections() {
		try {
			const secret = sessionStorage.getItem('participantSecret');
			const res = await fetch(`${API_URL}/api/update_question_collections/`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					code,
					participant_id: participantId,
					secret,
					collections: selectedCollections
				})
			});
			if (!res.ok) {
				const data = await res.json();
				errorMessage = data.error || 'Nepavyko atnaujinti kolekcijų.';
				return;
			}
			const updated = await res.json();
			lobbyState.question_collections = updated.question_collections;
		} catch (err) {
			console.error(err);
			errorMessage = 'Serverio klaida atnaujinant kolekcijas.';
		}
	}

	async function startGame() {
		try {
			const secret = sessionStorage.getItem('participantSecret');
			const res = await fetch(`${API_URL}/api/start_game/`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ code, participant_id: participantId, secret })
			});
			if (!res.ok) {
				const data = await res.json();
				errorMessage = data.error || 'Nepavyko pradėti žaidimo.';
				return;
			}
		} catch (err) {
			console.error(err);
			errorMessage = 'Serverio klaida pradedant žaidimą.';
		}
	}

	async function selectCharacter(characterId) {
		const secret = sessionStorage.getItem('participantSecret');
		const res = await fetch(`${API_URL}/api/select_character/`, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({
				code,
				participant_id: participantId,
				secret,
				character_id: characterId
			})
		});
		if (!res.ok) {
			const data = await res.json();
			errorMessage = data.error || 'Nepavyko pasirinkti personažo.';
		}
	}

	async function createCharacter() {
		if (!newCharacterName) {
			errorMessage = 'Įveskite personažo vardą.';
			return;
		}
		const secret = sessionStorage.getItem('participantSecret');
		const formData = new FormData();
		formData.append('code', code);
		formData.append('participant_id', participantId);
		formData.append('secret', secret);
		formData.append('name', newCharacterName);
		formData.append('description', newCharacterDescription);
		if (newCharacterImage && newCharacterImage.files.length > 0) {
			formData.append('image', newCharacterImage.files[0]);
		}
		const res = await fetch(`${API_URL}/api/create_character/`, {
			method: 'POST',
			body: formData
		});
		if (!res.ok) {
			const data = await res.json();
			errorMessage = data.error || 'Nepavyko sukurti personažo.';
		}
	}

	async function sendChatMessage() {
		const text = chatInput.trim();
		if (!text) return;
		try {
			const res = await fetch(`${API_URL}/api/send_chat_message/`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					code,
					participant_id: participantId,
					secret: sessionStorage.getItem('participantSecret'),
					text
				})
			});
			if (!res.ok) {
				const data = await res.json();
				errorMessage = data.error || 'Nepavyko išsiųsti žinutės.';
			} else {
				chatInput = '';
			}
		} catch (err) {
			console.error(err);
			errorMessage = 'Serverio klaida siunčiant žinutę.';
		}
	}

	let guessOptions = []; // holds /api/available_guess_options/
	let guessMap = {}; // Map: { [opponentId]: guessedCharacterId }

	async function fetchGuessOptions() {
		try {
			const res = await fetch(
				`${API_URL}/api/available_guess_options/?code=${encodeURIComponent(code)}`
			);
			if (res.ok) {
				guessOptions = await res.json();
			} else {
				console.error('Nepavyko gauti galimų spėjimų.');
			}
		} catch (err) {
			console.error('Nepavyko gauti galimų spėjimų:', err);
		}
	}

	async function submitGuesses() {
		// Build the guesses array; only include opponents for whom a guess was selected.
		let guessesArray = [];
		for (const player of players) {
			if (String(player.id) === String(participantId)) continue; // skip self
			const guessedCharId = guessMap[player.id];
			if (guessedCharId) {
				guessesArray.push({
					guessed_participant_id: player.id,
					guessed_character_id: parseInt(guessedCharId, 10)
				});
			}
		}
		try {
			const res = await fetch(`${API_URL}/api/submit_guesses/`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					code,
					participant_id: participantId,
					secret: participantSecret,
					guesses: guessesArray
				})
			});
			if (!res.ok) {
				const data = await res.json();
				errorMessage = data.error || 'Nepavyko pateikti spėjimų.';
			} else {
				const data = await res.json();
				console.log('Guesses submitted:', data);
			}
		} catch (err) {
			console.error(err);
			errorMessage = 'Serverio klaida teikiant spėjimus.';
		}
	}

	$: if (lobbyState.status === 'guessing') {
		fetchGuessOptions();
	}

	let guessTimeLeft = 0;

	function updateGuessTimeLeft() {
		if (lobbyState.guess_deadline) {
			const deadline = new Date(lobbyState.guess_deadline);
			guessTimeLeft = Math.max(0, Math.floor((deadline - Date.now()) / 1000));
		}
	}
	const guessTimerInterval = setInterval(updateGuessTimeLeft, 1000);

	onMount(() => {
		const storedRoom = sessionStorage.getItem('roomCode');
		const storedId = sessionStorage.getItem('participantId');
		const storedSecret = sessionStorage.getItem('participantSecret');

		// If the stored room code doesn't match the current room, clear credentials.
		if (storedRoom !== code) {
			sessionStorage.removeItem('participantId');
			sessionStorage.removeItem('participantSecret');
		}

		// After that, if there are valid stored credentials, try to rejoin.
		if (sessionStorage.getItem('participantId') && sessionStorage.getItem('participantSecret')) {
			rejoinRoom();
		} else {
			// Otherwise, simply connect the WebSocket (the guest form will be shown)
			connectWebSocket();
		}
		fetchAvailableCharacters();
	});

	onDestroy(() => {
		if (heartbeatInterval) clearInterval(heartbeatInterval);
		if (socket) socket.close();
		clearInterval(timerInterval);
		clearInterval(guessTimerInterval);
	});
</script>

{#if needsUsername}
	<!-- Guest user: Show username input form -->
	<h2>Kambario kodas: {code}</h2>
	<p>Prašome įvesti vartotojo vardą, kad prisijungtumėte prie kambario.</p>
	<input class="border" type="text" bind:value={guestUsername} placeholder="Vartotojo vardas" />
	<button class="border" on:click={submitGuestUsername}>Prisijungti</button>
	{#if errorMessage}
		<p class="error">{errorMessage}</p>
	{/if}
{:else}
	<!-- Conditional UI based on lobby status -->
	{#if lobbyState.status === 'pending'}
		<!-- Lobby View -->
		<h2>Kambario kodas: {code}</h2>
		<p>Žaidėjai kambaryje:</p>
		<ul>
			{#each players as player}
				<li>
					{#if String(player.id) === String(participantId)}
						<strong>{player.username}</strong>
					{:else}
						{player.username}
					{/if}
					{#if player.is_host}
						<span> 👑</span>
					{/if}
					{player.characterSelected ? ' ✅' : ''}
				</li>
			{/each}
		</ul>
		<!-- Display current guess timer setting to all users -->
		<p>Spėjimų laikas: {guessTimer} s</p>
		<div class="room-settings">
			<h3>Kambario nustatymai</h3>
			<p>Round Length: {roundLength} s</p>
			<p>Round Count: {roundCount}</p>
			{#if lobbyState.question_collections}
				<h4>Pasirinktos klausimų kolekcijos:</h4>
				<ul>
					{#each lobbyState.question_collections as qc}
						<li>{qc.name}</li>
					{/each}
				</ul>
			{/if}
		</div>
		{#if isHost}
			<div class="host-settings">
				<h3>Nustatymai (Tik vedėjui)</h3>
				<label>
					Round Length (s):
					<input type="number" bind:value={roundLength} min="1" />
				</label>
				<label>
					Round Count:
					<input type="number" bind:value={roundCount} min="1" />
				</label>
				<label>
					Spėjimų laikas (s):
					<input type="number" bind:value={guessTimer} min="1" />
				</label>
				<button class="border" on:click={updateSettings}>Atnaujinti nustatymus</button>
				<h3>Klausimų kolekcijos</h3>
				{#if availableCollections.length > 0}
					{#each availableCollections as collection}
						<div>
							<input
								type="checkbox"
								id="qc-{collection.id}"
								value={collection.id}
								bind:group={selectedCollections}
							/>
							<label for="qc-{collection.id}">{collection.name}</label>
						</div>
					{/each}
					<button class="border" on:click={updateCollections}>Atnaujinti kolekcijas</button>
				{:else}
					<p>Nėra prieinamų klausimų kolekcijų.</p>
				{/if}
				<button class="border" on:click={startGame}>Pradėti žaidimą</button>
			</div>
		{/if}
		<h3>Pasirinkite savo personažą</h3>
		<div>
			<h4 class="flex flex-col">Pasirinkti iš esamų:</h4>
			{#each availableCharacters as char}
				<button on:click={() => selectCharacter(char.id)}>
					{#if char.image}
						<img src="{API_URL}{char.image}" alt={char.name} width="100" />
					{:else}
						<img src="/fallback_character.jpg" alt="Fallback Character" width="100" />
					{/if}
					<span>{char.name}</span>
				</button>
			{/each}
		</div>
		<div>
			<h4>Sukurti naują personažą:</h4>
			<input type="text" bind:value={newCharacterName} placeholder="Personažo vardas" />
			<textarea bind:value={newCharacterDescription} placeholder="Aprašymas"></textarea>
			<input type="file" bind:this={newCharacterImage} accept="image/*" />
			<button on:click={createCharacter}>Sukurti ir pasirinkti</button>
		</div>
	{:else if lobbyState.status === 'in_progress'}
		<!-- Game View: Display current round details and chat -->
		{#if currentRound.round_number}
			<div class="round-info" style="margin-bottom: 1rem;">
				<h3>Raundas {currentRound.round_number}</h3>
				<p>Klausimas: {currentRound.question}</p>
				<p>Liko laiko: {timeLeft}s</p>
			</div>
		{:else}
			<p>Šiuo metu nėra aktyvaus raundo.</p>
		{/if}
		<div class="chat-container" style="border: 1px solid #ccc; padding: 1rem;">
			<h3>Game Chat</h3>
			<div class="messages-list" style="max-height: 300px; overflow-y: auto;">
				{#each chatMessages as msg}
					<div
						class="message-item"
						style="margin-bottom: 0.5rem; padding: 0.5rem; border-bottom: 1px solid #eee;"
					>
						<div class="message-sender" style="display: flex; align-items: center;">
							{#if msg.characterImage}
								<img
									src="{API_URL}{msg.characterImage}"
									alt="Char"
									width="40"
									style="margin-right: 0.5rem;"
								/>
							{:else}
								<img
									src="/fallback_character.jpg"
									alt="Fallback"
									width="40"
									style="margin-right: 0.5rem;"
								/>
							{/if}
							<strong>{msg.characterName}:</strong>
						</div>
						<div class="message-text">{msg.text}</div>
						<div class="message-time" style="font-size: 0.8rem; color: #888;">
							{new Date(msg.sentAt).toLocaleTimeString()}
						</div>
					</div>
				{/each}
			</div>
			<div class="message-input" style="margin-top: 0.5rem;">
				<input
					type="text"
					bind:value={chatInput}
					placeholder="Rašyk žinutę..."
					on:keydown={(evt) => evt.key === 'Enter' && sendChatMessage()}
					style="width: 80%; padding: 0.5rem;"
				/>
				<button on:click={sendChatMessage} style="padding: 0.5rem;">Siųsti</button>
			</div>
		</div>
	{:else if lobbyState.status === 'guessing'}
		<!-- Guessing View -->
		<div class="guessing-view">
			<h2>Atspėk draugus! 👀</h2>
			<p>Liko laiko spėjimams: {guessTimeLeft}s</p>
			<p>Pasirink, kurį personažą, manai, žaidžia kiekvienas iš kitų žaidėjų.</p>
			<div class="guessing-panel">
				{#each players as player}
					{#if String(player.id) !== String(participantId)}
						<div class="guessing-card">
							<p><strong>{player.username}</strong></p>
							<select bind:value={guessMap[player.id]}>
								<option value="" disabled selected>Pasirink personažą</option>
								{#each guessOptions as option}
									<option value={option.character_id}>{option.character_name}</option>
								{/each}
							</select>
						</div>
					{/if}
				{/each}
			</div>
			<button class="border" on:click={submitGuesses} disabled={guessTimeLeft === 0}
				>Pateikti spėjimus</button
			>
			{#if errorMessage}
				<p class="error">{errorMessage}</p>
			{/if}
		</div>
	{:else if lobbyState.status === 'completed'}
		<div class="completed-view">
			<h2>Žaidimas baigtas!</h2>
			<h3>Rezultatai:</h3>
			<ul>
				{#each players as player}
					<li>{player.username}: {player.points} taškai</li>
				{/each}
			</ul>
			<button class="border" on:click={leaveLobby}>Išeiti</button>
		</div>
	{/if}
	<button class="border" on:click={leaveLobby}>Palikti kambarį</button>
	{#if errorMessage}
		<p class="error">{errorMessage}</p>
	{/if}
{/if}


===== docker-compose.yml =====
services:
  db:
    image: postgres
    container_name: rpg_db
    env_file:
      - .env
    environment:
      POSTGRES_DB: rpgdb
      POSTGRES_USER: rpguser
      POSTGRES_PASSWORD: rpgpass
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - rpg_net

  redis:
    image: redis:7-alpine
    container_name: rpg_redis
    networks:
      - rpg_net

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: rpg_backend
    command: >
      sh -c "
        python manage.py migrate &&
        python manage.py collectstatic --noinput &&
        daphne -b 0.0.0.0 -p 8000 backend.asgi:application
      "
    volumes:
      - ./backend:/app
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis
    env_file:
      - .env
    environment:
      DB_NAME: rpgdb
      DB_USER: rpguser
      DB_PASSWORD: rpgpass
      DB_HOST: db
      DB_PORT: 5432
      REDIS_URL: redis://redis:6379
    networks:
      - rpg_net

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        VITE_API_BASE_URL: "http://localhost:8000"
    container_name: rpg_frontend
    ports:
      - "3000:80" # 80 in container -> 3000 on host
    depends_on:
      - backend
    networks:
      - rpg_net

  celery:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: rpg_celery
    command: celery -A backend worker -l info
    volumes:
      - ./backend:/app
    depends_on:
      - backend
      - redis
    env_file:
      - .env
    environment:
      DB_NAME: rpgdb
      DB_USER: rpguser
      DB_PASSWORD: rpgpass
      DB_HOST: db
      DB_PORT: 5432
      REDIS_URL: redis://redis:6379
    networks:
      - rpg_net

  celery-beat:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: rpg_beat
    command: celery -A backend beat -l info
    volumes:
      - ./backend:/app
    depends_on:
      - backend
      - redis
    env_file:
      - .env
    environment:
      DB_NAME: rpgdb
      DB_USER: rpguser
      DB_PASSWORD: rpgpass
      DB_HOST: db
      DB_PORT: 5432
      REDIS_URL: redis://redis:6379
    networks:
      - rpg_net

networks:
  rpg_net:

volumes:
  postgres_data:


